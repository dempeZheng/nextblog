---
layout: post
title:  "重试机制"
date:  2017-08-26
categories: [微服务]
keywords: 微服务,重试,幂等,超时
---

重试机制就是一种容错机制。
我们在nginx里面可以看到重试机制；
在httpclient的实现里面也可以看到retryHandler；
在 dubbo里面也能找到retry先关的东西
...
在对服务可用性要求比较高的互联网行业，重试机制经常被提及。
本文旨在梳理重试机制的使用场景，核心点，以及优雅的使用方式做一个梳理。

## 适用场景

功能逻辑中存在不稳定依赖场景，需要使用重试获取预期结果或者尝试重新执行逻辑不立即结束。比如远程接口访问，数据加载访问，定时任务结算

**具体的业务场景如下：**

>1.某个服务依赖第三方服务，但是第三方服务不够稳定，这个时候我们可以通过重试，来提供服务的可靠性
2.某个包月扣费的task，我们需要保证任务在结算日被成功执行，这个时候我们也可以依赖重试机制来保障服务的可靠性。（这种情况要注意幂等重试）
3.异步化的的进程中，通过会在某个核心逻辑处理完后就返回业务成功，后续的逻辑通常使用异步线程来完成。这个时候也可以通过重试机制来提高业务的可靠性。（当然使用队列来做异步也是个不错的选择）
4.现在很多服务都部署了多个节点，为了避免部分节点宕机对业务造成的影响，通常需要一定的容灾机制，最常见的机制就是failover，基于负载均衡的重试
...

相较于适用的场景，重试时需要特别小心场景更值得让人关注。

场景一：

>例如接口超时，你是无法判断接口到底有无正确处理，如果接口不是幂等的，重试了，很可能造成脏写。

**结论：非幂等情况下，千万不可重试。**

场景二：

>业务接口方服务cpu紧张，造成接口失败或者超时，这个时候盲目重试只能拖垮依赖服务。

**结论：针对不同的业务场景，需选择不同的重试策略。**

## 基于spring-retry的重试
在看到[spring-retry](https://github.com/spring-projects/spring-retry)之前我从未想到过将retry封装成一个组件，最多觉得是抽象几个重试的策略。
直到我看到`spring-retry`的用法，才突然意识到重试机制其实可以封装成面向任何方法的组件。只要将方法逻辑包装在一个重试代码块里面即可。而这种场景用代理模式实现就更更合适不过了，所以spring-retry支持基于注解的面向切面的重试组件还是很惊艳的。
下文会贴一些简单的示例，便于对重试的实现有一个基本的了解。
如需对`spring-retry`更深入的了解学习，建议直接看github的readme和源代码。https://github.com/spring-projects/spring-retry

### spring-retry的使用示例

```java
RetryTemplate template = new RetryTemplate();

TimeoutRetryPolicy policy = new TimeoutRetryPolicy();
policy.setTimeout(30000L);

template.setRetryPolicy(policy);

Foo result = template.execute(new RetryCallback<Foo>() {

    public Foo doWithRetry(RetryContext context) {
        // Do stuff that might fail, e.g. webservice operation
        return result;
    }

});
```

### 面向切面的使用示例

``` java
Configuration
@EnableRetry
public class Application {

    @Bean
    public Service service() {
        return new Service();
    }

}

@Service
class Service {
    @Retryable(maxAttempts=12, backoff=@Backoff(delay=100, maxDelay=500))
    public service() {
        // ... do something
    }
}
```
【注】这里面向切面的实现方式很惊艳，而且相关实现的也很有用。

比如我们在接口开发中，需要对部分提供的接口幂等，那么也可以实现一个注解，来标识了该注解的方法做幂等。
这里暂不是深入讨论相关实现。
有兴趣的可以去看spring-retry中的`AnnotationAwareRetryOperationsInterceptor`，`RetryConfiguration`，参考它，很容易实现出任何可以用切面实现的轮子。

### spring-retry的基本概念

### 重试策略
`NeverRetryPolicy`：只允许调用RetryCallback一次，不允许重试；
`AlwaysRetryPolicy`：允许无限重试，直到成功，此方式逻辑不当会导致死循环；
`SimpleRetryPolicy`：固定次数重试策略，默认重试最大次数为3次，RetryTemplate默认使用的策略；
`TimeoutRetryPolicy`：超时时间重试策略，默认超时时间为1秒，在指定的超时时间内允许重试；
`CircuitBreakerRetryPolicy`：有熔断功能的重试策略，需设置3个参数openTimeout、resetTimeout和delegate；
`CompositeRetryPolicy`：组合重试策略，有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即可以，但不管哪种组合方式，组合中的每一个策略都会执行。

#### 重试退避策略
spring-rety还实现了一种重试的退避策略，这种在很多场景下很有用。
BackOffPolicy 提供了如下策略实现：

`NoBackOffPolicy`：无退避算法策略，即当重试时是立即重试；
`FixedBackOffPolicy`：固定时间的退避策略，需设置参数sleeper和backOffPeriod，sleeper指定等待策略，默认是Thread.sleep，即线程休眠，backOffPeriod指定休眠时间，默认1秒；
`UniformRandomBackOffPolicy`：随机时间退避策略，需设置sleeper、minBackOffPeriod和maxBackOffPeriod，该策略在[minBackOffPeriod,maxBackOffPeriod之间取一个随机休眠时间，minBackOffPeriod默认500毫秒，maxBackOffPeriod默认1500毫秒；
`ExponentialBackOffPolicy`：指数退避策略，需设置参数sleeper、initialInterval、maxInterval和multiplier，initialInterval指定初始休眠时间，默认100毫秒，maxInterval指定最大休眠时间，默认30秒，multiplier指定乘数，即下一次休眠时间为当前休眠时间*multiplier；
`ExponentialRandomBackOffPolicy`：随机指数退避策略，引入随机乘数，之前说过固定乘数可能会引起很多服务同时重试导致DDos，使用随机休眠时间来避免这种情况。


#### 重试上下文状态
　无状态重试，是在一个循环中执行完重试策略，即重试上下文保持在一个线程上下文中，在一次调用中进行完整的重试策略判断。
　　非常简单的情况，如远程调用某个查询方法时是最常见的无状态重试。
　　
有状态重试，有两种情况需要使用有状态重试，事务操作需要回滚或者熔断器模式。
　　事务操作需要回滚场景时，当整个操作中抛出的是数据库异常DataAccessException，则不能进行重试需要回滚，而抛出其他异常则可以进行重试，
　
#### 重试的RecoverCallback

### spring-retry机制的局限
尽管很多场景下，我们都可以通过spring-retry帮我们搞定重试，但是spring-retry重试实体限定为Throwable子类，很多情况我们是需要根据具体的返回对象的状态吗来决定是否重试。如果spring-retry能够抽象一个类似`<R> booble isNeedRetry(R r)`的抽象方法应该会方便很多。
当然，对于这个问题，还是有很多解决办法的。
比如使用注解的时候，我们将方法包装一下，将返回码解析出来显示的抛出异常状态就好了。


##  guava retryer
guava也有retry的相关实现，且guava出品一般都是良品。

  函数式的调用比较流畅，只可惜没有注解的实现，如果项目是spring生态的还是推荐使用spirng-retry

```java
Retryer<Boolean> retryer = RetryerBuilder.<Boolean>newBuilder()
          .retryIfResult(Predicates.equalTo(false))
          .retryIfException()
          .withWaitStrategy(WaitStrategies.fixedWait(1, TimeUnit.SECONDS))
          .withStopStrategy(StopStrategies.stopAfterAttempt(5))
          .withRetryListener(new MyRetryListener<>())
          .withRetryListener(new MyRetryListener<>())
          .build();
```


## 基于负载均衡的重试
基于负载均衡的重试单独拿出来，是因为对这个比较困惑，也正是因为在定制一个client的时候希望实现关于负载均衡的重试才来整理重试机制的。

负载均衡+重试机制组合起来策略太多了。不太清楚有没有一种优雅的方式能实现两种的任意组合，任意定制。

看了`springcloud ribbon`重试部分的代码，虽然是基于spring-rety实现的，但是感觉扩展起来比较受限。策略这种因场景而异的东西还是希望能够提供能活的实现机制比较好。
个人比较期待能有一个针对负载均衡的重试策略的抽象类(大概就是基础的loadbalancer里面加上抽象的retryPolicy)，可以继承出来随便扩展，不过比较可惜，目前读的版本貌似没有这样的方法。
这一块现在也在困惑期，等理清楚逻辑后再来补充。

----
## 后记
和重试相关的东西其实还有[幂等](http://code.zhizus.com/2017-08-28-%E5%B9%82%E7%AD%89.html)和`超时`。一般说到重试都会说幂等重试`，`超时重试`

## 参考文档

http://blog.csdn.net/paul_wei2008/article/details/53871442
http://blog.csdn.net/broadview2006/article/details/72841056
[spring-retry](https://github.com/spring-projects/spring-retry)


