---
layout: post
title:  "电路熔断器模式"
date:  2017-08-30
categories: [微服务]
keywords: 微服务,熔断器,hystrix,Circuit,Breaker
---

## 概念

电路熔断器模式(`Circuit Breaker Patten`), 该模式的原理类似于家里的电路熔断器，如果家里的电路发生短路，熔断器能够主动熔断电路，以避免灾难性损失。在分布式系统中应用电路熔断器模式后，当目标服务慢或者大量超时，调用方能够主动熔断，以防止服务被进一步拖垮；如果情况又好转了，电路又能自动恢复，这就是所谓的弹性容错，系统有自恢复能力。下图Fig 8是一个典型的具备弹性恢复能力的电路保护器状态图，正常状态下，电路处于关闭状态(Closed)，如果调用持续出错或者超时，电路被打开进入熔断状态(Open)，后续一段时间内的所有调用都会被拒绝(Fail Fast)，一段时间以后，保护器会尝试进入半熔断状态(Half-Open)，允许少量请求进来尝试，如果调用仍然失败，则回到熔断状态，如果调用成功，则回到电路闭合状态。
![Alt text](/images/1125007.png)
## 应用场景

当一个应用需要执行一些访问远程资源或者是远端服务的时候，是很容易碰到一些偶然的错误的，比如说，网络连接速度很慢，超时，或者是资源的过量使用，或者临时资源不再可用等等。这一类的错误通常来说会在短暂的时间内，自动恢复过来。一个健壮的云应用也该能够通过一些策略能够处理这类错误，比如使用重试模式。
然而，也有一些情况，错误是出于一些意想不到的事件，这类事件很难预期，而且需要消耗很多时间来自动恢复。这些错误在严重性上也从丢失部分连接到整个服务的失败。在这些情况下，让应用继续重试或者执行操作就已经没有意义了。相对的，应用应该迅速令服务失败，而根据错误类型来尝试采取对应的措施。
另外，如果一个服务非常繁忙，系统的部分错误有可能会导致雪崩效应。举例来说，一个操作其他服务的操作可以配置超时时间的，如果服务再一段时间无法应答，调用方可以返回错误信息的。然而这个策略可能导致大量针对这个服务的请求阻塞直至Timeout时间到了。这些阻塞的请求可能会持有系统关键的资源，比如内存，线程，数据库连接等等信息。因此，引用的资源也可能会被耗尽，造成系统内其他不相关部分得失败。在这些情况下，最好的方法是令这些配置超时的操作立刻失败，并且只有当服务可能成功的时候才去调用。当然，配置较短的超时时间也能改善这一问题，但是超时时间如果配置的太短，服务的调用反而会因为大量的超时而失败。`如果说重试机制是服务的最后一根救命稻草，那么电路熔断机制更像是一种及时止损，自我保护的机制`。

由于某些原因使得服务出现了问题，很多时候刚开始可能只是系统出现了局部的、小规模的故障，然而由于种种原因，故障影响的范围越来越大，最终导致了全局性的后果。**为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为过载保护**。

**使用该模式：**
当需要阻止应用不断尝试调用远端服务或者访问共享资源，并且这些请求很容易失败的时候使用Circuit-Breaker模式很合适。

**什么场景不适合使用该模式：**
当用来处理访问本地资源，比如内存中的数据结构的时候，不适合使用。在这种场景下，Circuit-Breaker只会给应用带来额外的负担。
将`Circuit-Breaker`作为处理应用中的业务逻辑中的异常处理的一部分也是不合适的。

**总结：**一般在调用不稳定的外部服务的时候可以考虑使用电路熔断器模式。

## 解决方案
Circuit-Breaker模式可以防止应用重复的尝试调用容易失败的操作，当`Circuit-Breaker`模式判断错误会持续的时候，它会令操作不再持续等待，以免继续浪费CPU资源。当然，`Circuit-Breaker`模式也令应用本身可以发现错误有没有被修复。如果发生的问题已经被修复了，应用可以重新尝试去调用服务。

>Circuit-Breaker模式的目的和Retry模式的目的是不同的。Retry模式令应用不断的重试调用，直到最后成功。而Circuit-Breaker模式是阻止应用继续尝试无意义的请求。应用可以同时使用两种模式。然而，重试逻辑应用对于所有的Circuit-Breaker返回的异常十分敏感，这样可以在`Circuit-Breaker`发现错误短时间无法修复的情况下直接不再继续重试。


## 需要考虑的问题

开发者在实现Circuit-Breaker模式的时候，有如下的一些地方需要注意：
- **异常的处理**：应用如果通过Circuit-Breaker来调用操作的话，就必须能够处理操作失效所引起的异常。而处理这些异常的代码将会和应用是高度相关的。举例来说，应用可以选择暂时降低其服务，调用其他的操作来达到完成相同的任务，或者获取相同的数据，或者抛出异常给用户令其稍后重试。
- **日志**：Circuit-Breaker应该把所有的失败请求都记录日志（和可能成功的请求），这样可以让管理员监控到外部调用的健康状态。
- **恢复性**：开发者应该为其保护的远端调用进行合理的配置来匹配远端调用的恢复模式。举例来说，如果Circuit-Breaker配置的停留在打开状态很久的话，就算远端服务已经可用了，因为Circuit-Breaker的打开状态，会令服务的状态仍然处于不可用状态。类似的，如果配置Circuit-Breaker的恢复时间太快，也会让应用在打开状态和半开状态之间不断震荡。
- **手动覆盖**：在某个系统中，如果其失效的时间是可见的，Circuit-Breaker也可以提供一些手动恢复的选项，来令管理员强制的关闭Circuit-Breaker。类似的，管理员也可以在远端服务暂时失效的情况下强制性配置Circuit-Breaker进入打开状态（重启超时Timer）
- **加速断路**：有的时候，错误的应答信息足够判断当前的状态而让Circuit-Breaker立刻触发。举个例子：如果一个Shard的返回信息表示，不建议立刻重试，希望在几分钟后重试的时候，那么Circuit-Breaker就不需要计数器到达阈值在进入Open状态了。
- **重演失败请求**：在打开状态，相对于让服务快速的失败，Circuit-Breaker也可以记录具体的请求，然后在稍后的时间，重新令这些失败的请求再来请求。
- **外部请求上的不恰当超时时间**：如果对于外部请求的超时时间配置的过长的话，Circuit-Breaker可能很难保护应用。如果超时时间过长，运行Circuit-Breaker的线程可能在认为服务失败之前，就被完全阻塞了。这种情况下，应用的实例就算是Circuit-Breaker触发了，进入了Open状态，也会有相当数量的线程处于阻塞状态的。

>HTTP协议定义：503表示服务不可用，如果请求的服务当前在web服务器上面不可用，就可以返回503。这个应答信息就可以包含额外的信息，比如期望的延迟重试时间。

## Hystrix Circuit Breaker
对电路熔断器提供了标准的实现，目前业界的所说的熔断大部分也是指的 Hystrix Circuit Breaker。
{% fi /images/circuit-breaker-1280.png, alt %}

**电路断路器的开闭模式如下：**
1.假定请求达到一个确定的阈值，（熔断器在整个统计时间内是否开启的阀值，默认20秒。也就是10秒钟内至少请求20次，熔断器才发挥起作用 ，如果低于这个阈值，就不会走熔断器的逻辑）
(HystrixCommandProperties.circuitBreakerRequestVolumeThreshold())...
2.假定失败率百分比超过一个确定的阈值，
(HystrixCommandProperties.circuitBreakerErrorThresholdPercentage())...
3.然后，电路断路器由闭合状态变为打开状态，
4.一旦断路器打开，经由这个断路器的所有请求都短路了。
5.经过一段时间
(HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds())
下一个请求被允许通过，(这就是 HALF-OPEN 状态)如果这个请求失败了，断路器模式转变为断开，持续一个时间段。如果请求成功，断路器转变为闭合的状态，然后跳到1逻辑，循环。

【注】熔断器如果能配置负载均衡就很完美了，在某个节点触发熔断时，自动隔离，一段时间后半开状态，...


每个熔断器默认维护10个bucket,每秒一个bucket,每个blucket记录成功,失败,超时,拒绝的状态，
默认错误超过50%且10秒内超过20个请求进行中断拦截.

###   熔断器的状态机

**Closed**：熔断器关闭状态，调用失败次数积累，到了阈值（或一定比例）则启动熔断机制；
**Open**：熔断器打开状态，此时对下游的调用都内部直接返回错误，不走网络，但设计了一个时钟选项，默认的时钟达到了一定时间（这个时间一般设置成平均故障处理时间，也就是MTTR），到了这个时间，进入半熔断状态；
**Half-Open**：半熔断状态，允许定量的服务请求，如果调用都成功（或一定比例）则认为恢复了，关闭熔断器，否则认为还没好，又回到熔断器打开状态；


### 熔断器相关配置

| 参数           | 作用          | 备注    |
| ------------- |:-------------:| -----:|
|circuitBreaker.errorThresholdPercentage     | 失败率达到多少百分比后熔断	 | 默认值：50 |
| circuitBreaker.forceClosed      | 是否强制关闭熔断	`如果是强依赖，应该设置为true`|   |
| circuitBreaker.requestVolumeThreshold | 熔断触发的最小个数/10s      |   默认值：20 |
| circuitBreaker.sleepWindowInMilliseconds | 熔断多少秒后去尝试请求     |   默认值：5000 |


## 后记
1.熔断器还有其他的方式实现，比如vip就用了metrics中的SlidingTimeWindowReservoir来实现熔断器。
SlidingTimeWindowReservoir中的 ConcurrentSkipListMap会导致YGC时间变长，

2.spring-retry里面也实现了熔断重试的策略，感兴趣的可以去看看实现。

## 参考资料

https://github.com/Netflix/Hystrix/wiki/How-it-Works#CircuitBreaker
http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-servic
http://blog.ethanpark.cn/post/Circuit-Breaker%E6%A8%A1%E5%BC%8F