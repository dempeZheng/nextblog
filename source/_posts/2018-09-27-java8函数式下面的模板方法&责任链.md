---
layout: post
title:  "java8函数式下面的模板方法&责任链"
date:  2018-09-27 20:39:04
type: java
categories: [函数式]
keywords: java8,函数式, fp, 模板方法,责任链
---

## 写在前面
代码里面有大量用到模板方法，具体业务逻辑如下
```
1.校验
2.幂等
3.业务逻辑(扣余额，写日志)
4.后置业务
5.幂等后置操作
```
实现的方法就依靠一个模板方法，子类继承模板，来实现具体业务。整体逻辑还是比较清晰。

最近在看函数式编程，发现很多设计模式在函数式编程语言下已经没有太大的意义了。就顺手就java8的函数式来实现了一下模板方法模式。

涉及的知识点：
```
1.高阶函数
2.模板方法
3.责任链
4.柯里化
```

```java
import java.util.function.Function;

/**
 * @author dempezheng
 */
public final class ConsumeTemplate {


    /**
     * 函数式实现的模板方法
     *
     * @param req
     * @param verifyFunction
     * @param processorFunction
     * @param postProcessorFunction
     * @param idempotentFunction
     * @param <Req>
     * @return
     */
    public final static <Req extends ConsumeReq> ConsumeRep consume(Req req, VerifyFunction<Req> verifyFunction,
                                                                    ProcessorFunction<Req> processorFunction,
                                                                    PostProcessorFunction<Req> postProcessorFunction,
                                                                    IdempotentFunction<Req> idempotentFunction) {
        // 1.校验
        verifyFunction.verify(req);
        // 2.处理幂等
        ConsumeRep resp = idempotentFunction.preIdempotent(req);
        if (resp != null) {
            return resp;
        }
        // 3.处理核心业务逻辑
        resp = processorFunction.process(req);
        try {
            // 4.处理后置业务逻辑
            postProcessorFunction.postProcessor(req, resp);
        } finally {
            // 5.幂等后置处理
            postIdempotent(resp);
        }
        return resp;
    }

    /**
     * 柯里化消费接口
     *
     * @param <Req>
     * @return
     */

    public final static <Req extends ConsumeReq> Function<VerifyFunction<Req>, Function<ProcessorFunction<Req>, Function<PostProcessorFunction<Req>, Function<IdempotentFunction<Req>, Function<Req, ConsumeRep>>>>> curryingConsume() {
        return verifyFunction -> processorFunction -> postProcessorFunction -> idempotentFunction -> (Function<Req, ConsumeRep>) req ->
                consume(req, verifyFunction, processorFunction, postProcessorFunction, idempotentFunction);
    }

    protected static void postIdempotent(ConsumeRep rep) {
    }

}

interface IdempotentFunction<Req> {
    /**
     * 幂等处理
     *
     * @param req
     * @return
     */
    ConsumeRep preIdempotent(Req req);
}

interface VerifyFunction<Req> {
    /**
     * 前置校验
     *
     * @param req
     */
    void verify(Req req);
}

interface ProcessorFunction<Req> {
    /**
     * 核心业务处理
     *
     * @param req
     * @return
     */
    ConsumeRep process(Req req);
}

interface PostProcessorFunction<Req> {
    /**
     * 后置业务异步处理
     *
     * @param req
     */
    void postProcessor(Req req, ConsumeRep rep);
}
```

```java

import org.springframework.stereotype.Component;

import java.util.function.BiConsumer;
import java.util.function.UnaryOperator;


/**
 * @author dempezheng
 */
@Component
public class StorageConsumeService {

    /**
     * 仓库消费
     * ConsumeTemplate.consume(new ConsumeReq(), verify, processor, postProcessorFunction, idempotentFunction);
     *
     * @return
     */
    public ConsumeRep consume() {
        return ConsumeTemplate.curryingConsume()
                // 前置校验
                .apply(consumeReq -> {
                    // 参数校验 & token校验
                    paramFilter.andThen(tokenFilter)
                            // 高危用户校验
                            .andThen(riskUserFilter)
                            .apply(consumeReq);
                })
                // 业务处理器
                .apply(processor)
                // 后置业务处理器
                .apply((consumeReq, consumeRep) -> asynchronousConsumeLog.andThen(sendGiftEffect)
                        .andThen(sendBillboardEvent)
                        .andThen(sendRichLevelEvent)
                        .accept(consumeReq, consumeRep))
                // 幂等处理
                .apply(idempotentFunction)
                //请求参数
                .apply(new ConsumeReq());

    }


    final UnaryOperator<ConsumeReq> paramFilter = req -> req;
    final UnaryOperator<ConsumeReq> tokenFilter = req -> req;
    final UnaryOperator<ConsumeReq> riskUserFilter = req -> req;

    final BiConsumer<ConsumeReq, ConsumeRep> sendGiftEffect = (req, rep) -> {
        // 发送送礼特效
    };
    final BiConsumer<ConsumeReq, ConsumeRep> sendBillboardEvent = (req, rep) -> {
        // 发送榜单event
    };

    final BiConsumer<ConsumeReq, ConsumeRep> sendRichLevelEvent = (req, rep) -> {
        // 发送财富等级event
    };

    final BiConsumer<ConsumeReq, ConsumeRep> asynchronousConsumeLog = (req, rep) -> {
        // 异步写消费日志
    };
    public ProcessorFunction<ConsumeReq> processor = req -> null;

    public IdempotentFunction<ConsumeReq> idempotentFunction = (req) -> null;
}
```

