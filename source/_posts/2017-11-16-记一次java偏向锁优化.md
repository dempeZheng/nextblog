---
layout: post
title:  "记一次java偏向锁的优化"
date:  2017-11-16 20:39:04
type: case
categories: [case]
keywords: 偏向锁,高并发
---



## 场景
最近查找服务时延增长的问题，通过在jvm启动前加参数：`-XX:+PrintGCApplicationStoppedTime`，打印日志如下：

```
1.784: Total time for which application threads were stopped: 0.0541497 seconds, Stopping threads took: 0.0000441 seconds
1.933: Total time for which application threads were stopped: 0.0004939 seconds, Stopping threads took: 0.0000210 seconds
2.013: Total time for which application threads were stopped: 0.0003884 seconds, Stopping threads took: 0.0000223 seconds
2.014: Total time for which application threads were stopped: 0.0001317 seconds, Stopping threads took: 0.0000117 seconds
2.505: Total time for which application threads were stopped: 0.0007190 seconds, Stopping threads took: 0.0000516 seconds
2.519: Total time for which application threads were stopped: 0.0005469 seconds, Stopping threads took: 0.0000273 seconds
2.894: Total time for which application threads were stopped: 0.0002649 seconds, Stopping threads took: 0.0000723 seconds
3.171: Total time for which application threads were stopped: 0.0002707 seconds, Stopping threads took: 0.0000259 seconds
3.899: Total time for which application threads were stopped: 0.0006577 seconds, Stopping threads took: 0.0000253 seconds
4.057: Total time for which application threads were stopped: 0.0006618 seconds, Stopping threads took: 0.0000251 seconds
4.130: Total time for which application threads were stopped: 0.0007136 seconds, Stopping threads took: 0.0000615 seconds
4.218: Total time for which application threads were stopped: 0.0006155 seconds, Stopping threads took: 0.0000250 seconds
4.406: Total time for which application threads were stopped: 0.0006617 seconds, Stopping threads took: 0.0000289 seconds
4.427: Total time for which application threads were stopped: 0.0005132 seconds, Stopping threads took: 0.0000261 seconds
4.510: Total time for which application threads were stopped: 0.0002178 seconds, Stopping threads took: 0.0000296 seconds
4.622: [GC (Metadata GC Threshold) [PSYoungGen: 801127K->22368K(1223168K)] 820102K->41351K(4019712K), 0.0195913 secs] [Times: user=0.11 sys=0.07, real=0.02 secs] 
4.641: [Full GC (Metadata GC Threshold) [PSYoungGen: 22368K->0K(1223168K)] [ParOldGen: 18983K->29281K(2796544K)] 41351K->29281K(4019712K), [Metaspace: 34906K->34906K(1079296K)], 0.0481762 secs] [Times: user=0.39 sys=0.03, real=0.05 secs]
```
发现有大量的Total time for which application threads were stopped的日志，尽管耗时不多，但是比较密集，整体耗时也不算少。
查阅资料确认这个是由于线程进入safepoint导致的停顿。
那么safepoint是什么？
## SafePoint

>Safepoint是java代码中一个线程可能暂停执行的一个位置，SafePoint保存了其他位置没有的一些运行信息。在这个位置上保存了线程上下文的任何信息，包括对象或者非对象的内部指针。在接收到JVM的进入Stop The World 的信息，在safepoint上，用户线程会被挂起。如果JNI代码想要访问在安全点上的用户线程，那么JNI所在线程也会阻塞直到用户线程离开安全点。因为在安全点上jvm线程信息被很好的描述，所以特别适合做一些全局性的操作，例如代码反优化，线程快照等等。http://peg.hengtiansoft.com/article/jvm-zhong-de-safepoint/





>一个线程可以在SafePoint上，也可以不在SafePoint上。一个线程在SafePoint时，它的状态可以安全地其他JVM线程所操作和观测；不在SafePoint时，就不能。在SafePoint上不代表被阻塞（比如：JNI方法就可以在SafePoint上运行），但是被阻塞一定发生在SafePoint上。当JVM决定达到一个全局的SafePoint（也叫做Stop the World），JVM里面所有的线程都要在SafePoint上并且不能离开，直到JVM让线程允许为止。这对要求所有线程都要被良好的描述的操作(比如CG，代码反优化等等)非常有好处。一些JVM可以持有一些私有的线程到SafePoint上而不需要全局的SafePoint，比如Zing.当你写一些非安全的代码的时候，你必须假设SafePoint有可能发生在任何两个字节码之间。非安全代码的调用并不要求必须有安全点，但是他们可以包含一个或者多个安全点。所有类型的JVM有一些效率非常高的技巧和去快速的穿过SafePoint，线程并不需要真正地进入SafePoint除非虚拟机指示线程这么做。所有的JNI方法都在SafePoint上执行。在安全点，JNI代码都不能改变和观测发起调用JNI代码线程的java机器状态。任何通过JNI API改变和观测调用线程的状态必须在调用线程离开安全点之后，以及再次进入SafePoint之前的时间内发生。 

深入了解 ，请查阅：https://www.zhihu.com/question/57722838/answer/156390795

什时候线程需要进入SafePoint的呢
看一下OpenJDK里面关于safepoint的一些说明：

```
// Begin the process of bringing the system to a safepoint.    
// Java threads can be in several different states and are    
// stopped by different mechanisms:    
//    
//  1. Running interpreted    
//     The interpeter dispatch table is changed to force it to    
//     check for a safepoint condition between bytecodes.    
//  2. Running in native code    
//     When returning from the native code, a Java thread must check    
//     the safepoint _state to see if we must block.  If the    
//     VM thread sees a Java thread in native, it does    
//     not wait for this thread to block.  The order of the memory    
//     writes and reads of both the safepoint state and the Java    
//     threads state is critical.  In order to guarantee that the    
//     memory writes are serialized with respect to each other,    
//     the VM thread issues a memory barrier instruction    
//     (on MP systems).  In order to avoid the overhead of issuing    
//     a mem barrier for each Java thread making native calls, each Java    
//     thread performs a write to a single memory page after changing    
//     the thread state.  The VM thread performs a sequence of    
//     mprotect OS calls which forces all previous writes from all    
//     Java threads to be serialized.  This is done in the    
//     os::serialize_thread_states() call.  This has proven to be    
//     much more efficient than executing a membar instruction    
//     on every call to native code.    
//  3. Running compiled Code    
//     Compiled code reads a global (Safepoint Polling) page that    
//     is set to fault if we are trying to get to a safepoint.    
//  4. Blocked    
//     A thread which is blocked will not be allowed to return from the    
//     block condition until the safepoint operation is complete.    
//  5. In VM or Transitioning between states    
//     If a Java thread is currently running in the VM or transitioning    
//     between states, the safepointing code will wait for the thread to    
//     block itself when it attempts transitions to a new state.    
```
http://blog.csdn.net/iter_zc/article/details/41892567
读完也不能确认具体哪些场景会导致线程进入SafePoint,不过印象中貌似偏向锁的释放会涉及到SafePoint
google发现：

>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。

看到这里，我们至少有理由相信，偏向锁竞争失败也是导致线程进入SafePoint的一个原因。
接下来要详细了解一下偏向锁

## 偏向锁

## 优化
高并发场景，如何优化呢？
通过以下参数  `-XX:-UseBiasedLocking`禁用偏向锁。这一点在很多jvm性能调优里面也可以看到，说明偏向锁在高并发的损耗还是不容忽视的。

## 总结
