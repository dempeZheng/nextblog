---
layout: post
title:  "浮点数的精度"
date:  2017-09-12 12:39:04
type: 札记
categories: [札记]
keywords: 浮点数,精度,double,float
---

## 写在前面
最近，测试妹子发现超大数据会造成用户余额计算错误。之前已经修复过一次double类型的计算引起的精度丢失的问题，所以很快就查出来是mysql的double类型引起的。
说来惭愧，一直以来对浮点数丢失精度的问题都是一知半解，知道double，float类型的计算会引起精度问题，知道对于浮点数的计算要BigDecimal这个类型来处理，但是对于其中的详细原理一直是似懂非懂。如果不是最近业务和金钱相关，甚至到现在都懒得去了解相关知识。
很多人都和我一样，不太把这个浮点数问题当回事，也懒得去了解其原理。但是，浮点数的精度这个问题真的只是一个基础问题，如果做个金钱相关的业务，那这个应该是个必须考察的知识点。
所以，是非常值得花5~10min来了解学习浮点数的精度。

## 场景
随便来个例子，演示一下浮点数的 精度计算：
```java
Double a = 2.2;
Double b = 3.6;
System.out.println(a + b);
```
输出：

```console
5.800000000000001
```
对于完全不了解浮点数精度问题的同学，可能都不相信自己的眼睛，为什么计算机连小学生的计算都做不了；甚至有些老鸟，也会觉得奇怪，对于浮点数计算丢失精度一般人的直觉应该是在计算小数位数过多的时候，不能得出精确的结果，但是为什么就以为小数的计算也会不准确。
当然，要了解其中的缘由，我们得深入了解浮点数的存储，相信了解了浮点数的存储之后，一定会豁然开朗，以后再也不会被关于浮点数精度的问题困扰。

## 浮点数的存储方式

国际标准IEEE 754规定，任意一个二进制浮点数V都可以表示成下列形式：

![Alt text](/images/1505222990516.png)

>符号位(`Sign`) : (-1)^s 表示符号位，当s=0，V为整数；s=1，V为负数；
指数位（`Exponent`）:2^E 表示指数位,用于存储科学计数法中的指数数据，并且采用移位存储;
尾数部分（`Mantissa`）：M 表示有效数字，1≤M<2；尾数部分;

对于有效数字M和指数E，这个IEEE 754还规定了：
**有效数字M**
（1）1≤M<2，也即M可以写成1.xxxxx的形式，其中xxxxx表小数部分
（2）计算机内部保存M时，默认这个数第一位总是1，所以舍去。只保存后面的xxxxx部分，节省一位有效数字
**指数E（阶码）**
（1）E为无符号整数。E为8位，范围是0～255；E为11位，范围是0～2047
（2）因为科学计数法中的E是可以出现负数的，所以IEEE 754规定E的真实值必须再减去一个中间数（偏移值），127或1023

IEEE 754又规定了，浮点数分单精度双精度之分：

>32位的单精度浮点数，最高1位是符号位s，接着的8位是指数E，剩下的23位是有效数字M
64位的双精度浮点数，最高1位是符号位s，接着的11位是指数E，剩下的52位为有效数字M

**单精度float的存储：**
![Alt text](/images/1505223188647.png)
**双精度double的存储：**
![Alt text](/images/1505223452920.png)

 R32.24和R64.53的存储方式都是用科学计数法来存储数据的，比如8.25用十进制的科学计数法表示就为:8.25*$10^0$,而120.5可以表示为:1.205*$10^2$。而计算机不认识十进制的数据，他只认识0，1，所以在计算机存储中，首先要将上面的数更改为二进制的科学计数法表示，8.25用二进制表示可表示为1000.01。120.5用二进制表示为：1110110.1用二进制的科学计数法表示1000.01可以表示为1.0001*$2^3$,1110110.1可以表示为1.1101101*$2^6$[3],任何一个数都的科学计数法表示都为1.xxx*$2^n$,尾数部分就可以表示为xxxx,第一位都是1嘛，干嘛还要表示呀？可以将小数点前面的1省略，所以23bit的尾数部分，可以表示的精度却变成了24bit，道理就是在这里，那24bit能精确到小数点后几位呢，我们知道9的二进制表示为1001，所以4bit能精确十进制中的1位小数点，24bit就能使float能精确到小数点后6位，而对于指数部分，因为指数可正可负，8位的指数位能表示的指数范围就应该为:-127-128了，所以指数部分的存储采用移位存储，存储的数据为元数据+127，下面就看看8.25和120.5在内存中真正的存储方式。
     首先看下8.25，用二进制的科学计数法表示为:1.0001*$2^3$
按照上面的存储方式，符号位为:0，表示为正，指数位为:3+127=130 ,位数部分为,故8.25的存储方式如下图所示:

![Alt text](/images/1505223484994.png)

而单精度浮点数120.5的存储方式如下图所示:
![Alt text](/images/1505223515471.png)

## 产生误差的根源
了解了存储原理了后，我们来追踪前面浮点数计算例子中丢失精度的根源。
首先，我们分别用二进制来表示浮点数2.2和3.6
```
10.00110011001100110011001100110011001100110011001101
11.100110011001100110011001100110011001100110011001101
```
看到这里，你应该会觉得计算机表示小数很傻帽了，有些小数竟然无法精确表示。
我们知道双精度精确的有效位数也是有限的，对于超过精确范围的数据就会丢失，而丢失就会造成精度的丢失。

## 浮点数运算常见的问题

### double类型转BigDecimal容易踩的坑

```java
 double a = 2.2d;
 System.out.println(new BigDecimal(a));
```
输出：

```
2.20000000000000017763568394002504646778106689453125
```
**正确的打开方式**

```java
double a = 2.2d;
System.out.println(new BigDecimal(String.valueOf(a)));
```
结论：先将浮点数转为string类型，BigDecimal中传入string类型；

### 浮点数比较的问题

```java
double a = 2.2d;
double b = 2.199999999999999999999999999999d;
double c = 2.2d;
System.out.println(a == b);
System.out.println(a ==c);
```
这个返回 true ？ false？

```
true
true
```
**结论**：在double精度范围内，认为这两个数是相等的。这是不是个问题要视情况而定了，但是我们 应该知晓这个问题的存在。

### 小心浮点数类型转换

```java
float a = 2.2f;
double b = a;
double c = 2.2d;
System.out.println(b);
System.out.println(a == c);
System.out.println(b == c);

```
输出：

```
2.200000047683716
false
false
```
 诧异吗？其实了解了上面的原理，也不觉得奇怪了。你始终要记住，计算机无法精确的表示有些小数。
 涉及到浮点数的计算要多加小心了。

正确的打开方式：

```java
float a = 2.2f;
double c = 2.2d;
double b = Double.valueOf(String.valueOf(a));
double d = new BigDecimal(String.valueOf(a)).doubleValue();
System.out.println(b);
System.out.println(d);
System.out.println(b == c);
System.out.println(d == c);
```

**结论**：先将float转换为string，在转换为double，或者通过BigDecimal转换。记住，不要随便强转就好了。

### double 类型toString科学计数法的问题

```java
double a = 9876543210123456789.2d;
System.out.println(a);
```
输出：
```
9.876543210123457E18
```
double类型在超过一千万就会使用科学计数法，很多语言也支持将科学计数法的string转成double类型。但是在数据量大的时候，还是会丢失一些信息的，如例子中，后面三个数字的信息就给抹掉了。
**还有另外一个问题，也是我工作中遇到的问题：**
我们在接口参数签名的时候，将所有的参数转换为string，拼接，加salt，md5生成sign，对于有double类型的，double类型大数据会toString会使用科学计数法，这样调用方传字符串过来就签名失败了。
那么怎么样让double在toString的时候不适用科学计数法呢？

```java
double a = 9876543210123456789.2d;
System.out.println(new BigDecimal(a).toPlainString());//这个方法有多少位数就展示多少
```

## 总结

对于精度有要求的，特别是金钱类系统，我们尽量避免使用浮点型，这样后期就会少很多麻烦；另外，如果接手就项目，已经用了double类型来表示，也不必大惊小怪，只要我们在浮点数的运算和转换的时候小心谨慎一点，也出不了什么幺蛾子。
比如我们现在数据库还有double（32,2）表示余额，理论上存在丢失精度的可能，但是真出现这样的案例，账户余额，刨除小数位2位，还要有14位，已经算不清是多少钱了。即便是这种情况，也仅仅是小数位丢精度。
总的来说，对于浮点数的运算，不管新手或者老司机，多多留神。


## 参考资料
http://www.cnblogs.com/grefr/p/6088515.html
http://blog.csdn.net/rsp19801226/article/details/3085343
https://zhuanlan.zhihu.com/p/28162086

