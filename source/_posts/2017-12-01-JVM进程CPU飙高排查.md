---
layout: post
title:  "JVM进程CPU飙高排查"
date:  2017-12-01 12:39:04
type: case
categories: [case]
keywords: tcpdump,tcpcopy,压测,离线流量
---

java进程CPU飙高是比较常见的case，排查方案网上大把，这里简单做个整理和记录。

## 基本思路
1）`jps -l`找对对应进程pid
2）通过`top -H -p pid`找出耗用CPU消耗比较高的线程id
3）将线程id转成16进制
4）`jstack pid | grep -C 30 16进制的线程id`
网上大把都是这个思路，基本没啥问题，但是有几个小问题：
1.执行起来略微有点耗时，线上问题一般都比较紧急，争分夺秒，能省则省。
2.第二步到第四步有时间差，很可能真正过滤出来的并发当前CPU损耗较高的线程

既然这样，那么，如果有一个脚本来解决这个问题，那就再好不过。

## 祖传脚本

jvm_topn_thread.sh

```bash
#!/bin/ksh

# write by    : oldmanpushcart@gmail.com
# date        : 2014-01-16
# version     : 0.07

typeset top=${1:-10}
typeset pid=${2:-$(pgrep -u $USER java)}
typeset tmp_file=/tmp/java_${pid}_$$.trace

$JAVA_HOME/bin/jstack $pid > $tmp_file
ps H -eo user,pid,ppid,tid,time,%cpu --sort=%cpu --no-headers\
        | tail -$top\
        | awk -v "pid=$pid" '$2==pid{print $4"\t"$6}'\
        | while read line;
do
        typeset nid=$(echo "$line"|awk '{printf("0x%x",$1)}')
        typeset cpu=$(echo "$line"|awk '{print $2}')
        awk -v "cpu=$cpu" '/nid='"$nid"'/,/^$/{print $0"\t"(isF++?"":"cpu="cpu"%");}' $tmp_file
done

rm -f $tmp_file
```

## 使用方法

```bash
sh  jvm_topn_thread.sh n pid
```

例如 `sh jvm_topn_thread.sh 20 pid` 表示查看cpu消耗TOP 20个线程及相关信息。

## 总结
自从有了这个脚本之后，大大节省了排查相关问题的时间。脚本确实是提高效率的利器。