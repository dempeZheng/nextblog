---
layout: post
title:  "可靠的消息-解决分布式事务最佳实践"
date:  2017-09-10
categories: [事务]
keywords: 分布式事务,本地消息表,事务消息,rocketMQ,高并发
---
## 背景

服务化盛行的今天，分布式事务的场景也越来越多。高并发场景下的分布式事务也是程序设计中的长期以往的难题。
正是因为其复杂性，很多公司，在一些依赖分布式事务的场景，都没有的事务保障，数据不一致了，用户投诉才知道。

一提到分布式事务，很多人就进入了ACID的死胡同，不是二阶段，三阶段提交，就是paxos协议。这些强一致性模式不仅在应用实施上有相当大的难度，而且基本无法满足高并发场景。
高并发和强一致性像鱼和熊掌不可兼得。选择了高性能，我们必须牺牲掉强一致性（其实很多业务场景都是可以接受最终一致性的）。
依赖可靠消息来处理分布式事务是最常用的方式之一，也是相对比较容易实施，比较靠谱的方式，可以说是高并发场景的首选方案。

## 业务场景
>支付宝转账1万块钱到余额宝

如果是在同一个数据库，那么这个问题相当简单。本地事务就可以搞定

```sql
Begin transaction
         update user_zhifubao_account set amount=amount-10000 where userId=A;
         update user_yuebao_account set amount=amount+10000 where userId=B;
End transaction
commit;
```

显然，支付宝和余额宝他们不是同一个系统，他们在同一个数据库的可能性非常小。 所以本地事务的方案基本不可行。
怎么解决这个问题呢？

所以，一般的思路都是通过消息中间件来实现“`最终一致性`”：A系统扣钱，然后发条消息给中间件，B系统接收此消息，进行加钱。

## 错误的方案
方案一：
>有人可能想到了，把“发送消息”这个update DB和发送消息放在同1个事务里面，如果发送消息失败，update DB自动回滚。这样不就保证2个操作的原子性了吗？

这个方案最大的问题是消息发送涉及到网络问题，发送消息超时的情况，你根本没办法知道消息发送的状态。（超时是魔鬼）
比如，收到一个超时异常（实际上消息发送成功，返回的时候消息超时），然后回滚了Update DB的事务，这样就凭空产生了产生了1w，这个问题就大了。
方案二：
>先update DB，成功后发送队列消息，消息发送超时或者失败的情况，重试。（这里有可能产生重复消息，保证消费加钱的接口幂等就可以了）

这个方案的问题在重试部分，因为重试本质上只是一种补救策略，能最大化减小损失，但是不能严格意义上面来保证一定成功。
这个方案虽然low，因为它从理论上都没办法保证数据一致性。但并不是一无是处。
1）这个在稳定的服务器，出现重试仍然不成功的概率还是比较小的。
2）不一致了仍然有补救的措施，重试不成功的场景，可以写条日志，并发一条告警消息通知响应的人员，来人工补救数据。
很多追求多快好省的小公司，甚至某些知名互联网公司，在某些业务场景下，也是这么处理的，牺牲掉极少数用户的利益。

但是作为一个逻辑严谨的程序员，不应该选择这样的方案。
- 依赖人工处理的方案尽量规避，
- 即便有补救措施，仍然无法从逻辑上保证数据一致性。比如重试失败的时候机器突然掉电，连失败日志都没有记录，这种情况，依赖人工也没办法还原数据。

做技术的还是得有点技术人员的操守，既不能陷入技术逻辑的死胡同，也不能太没有太随便。

针对上面的错误方案，我们优化一下，就能很好的解决问题了。

## 使用消息队列来避免分布式事务

### 本地消息表

对于《方案二》，方案二的核心问题点在在于重试无法确保重试成功，如果要保证重试一定能够成功，那么必须将重试的任务持久化。持久化是数据可靠性的前提。那么将问题分解：
将update DB 和发送消息分解为一下三步：
1）update DB
2）持久化消息的Task表
3）定时扫描Task表发送消息
这样一来就简单了，只要保证1），2）那么久能确保发送消息成功。所以将1）2）放在同一个事务里面，将分布式的问题演化本地事务。

```
Begin transaction
         update user_zhifubao_account set amount=amount-10000 where userId=1;
         insert into message(userId, amount,status) values(1, 10000, 1);
End transaction
commit;
```

这种实现方式的思路，其实是源于ebay，后来通过支付宝等公司的布道，在业内广泛使用。其基本的设计思想是将远程分布式事务拆分成一系列的本地事务。如果不考虑性能及设计优雅，借助关系型数据库中的表即可实现。

>如果仔细观察生活的话，生活的很多场景已经给了我们提示。
比如在北京很有名的姚记炒肝点了炒肝并付了钱后，他们并不会直接把你点的炒肝给你，而是给你一张小票，然后让你拿着小票到出货区排队去取。


## MQ事务消息
对于《方案一》，我们是只需要保证 update DB 和发送消息都支持事务操作就可以了，这里，我们有很简单的解决办法，就是选择支持事务的消息中间件。让消息中间件来帮我们处理其中的细节问题。
下面以RocketMQ为例介绍一下mq事务消息的实现：
**概念介绍**
>**事务消息**：MQ 提供类似 X/Open XA 的分布事务功能，通过 MQ 事务消息能达到分布式事务的最终一致。
**半消息**：暂不能投递的消息，发送方已经将消息成功发送到了 MQ 服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半消息。
**消息回查**：由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，MQ 服务端通过扫描发现某条消息长期处于“半消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该过程即消息回查。

![Alt text](/images/mq_trans.png)

其中：
>1.发送方向 MQ 服务端发送消息；
2.MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。
3.发送方开始执行本地事务逻辑。
4.发送方根据本地事务执行结果向 MQ Server 提交二次确认（Commit 或是 Rollback），MQ Server 收到 Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 Rollback 状态则删除半消息，订阅方将不会接受该消息。
5.在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达 MQ Server，经过固定时间后 MQ Server 将对该消息发起消息回查。
6.发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。
7.发送方根据检查得到的本地事务的最终状态再次提交二次确认，MQ Server 仍按照步骤4对半消息进行操作。
事务消息发送对应步骤1、2、3、4，事务消息回查对应步骤5、6、7。

相比如本地方法表的方案，事务消息其实是把本地消息表的逻辑和task移到消息中间件来处理了。

## 总结
1）用消息队列来规避分布式事务需要注意Mq消息消费方需要支持消息幂等性能。特别是本地消息表这种方式，消息队列产生重复消息的概率很大，业务方一定要注意去重。
2）RocketMQ的事务消息设计很有参考价值，在设计数据一致性有要求的异步系统的时候，也可以参考这种模型，最典型的如支付系统。回查接口应该是支付系统的标配。
3）没有任何一种架构或者方案是万能良药，不同的业务场景需要选择不同的业务方案。

## 参考

https://coolshell.cn/articles/10910.html
https://help.aliyun.com/document_detail/43348.html?spm=5176.product29530.6.561.VdHw0Z